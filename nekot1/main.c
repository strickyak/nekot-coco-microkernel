#include "nekot1/private.h"

// main.c

// Use our alternate data sections.
gword _More0 gZEROED; // not .bss
gword _More1 gZEROED = 0x9998; // not .data
gword _Final __attribute__ ((section (".final"))) = 0x9990;
gword _Final_Startup __attribute__ ((section (".final.startup"))) = 0x9991;

// Hardware Reference -- Thanks, Tim!
//     https://tlindner.macmess.org/?page_id=767

// pia_reset_sequence table traced from coco3 startup.
struct pia_reset_sequence {
    gword addr;
    gbyte value;
} pia_reset_sequence[] gSETUP_DATA = {
    { 0xff21, 0x00 },  // choose data direction
    { 0xff23, 0x00 },  // choose data direction
    { 0xff20, 0xfe },  // bit 0 input; rest are outputs.
    { 0xff22, 0xfa },  // bit 1 and bits 3-7 are outputs.
    { 0xff21, 0x34 },
    { 0xff23, 0x34 },
    { 0xff22, 0x00 },  // output all 0s on Pia1 PortB
    { 0xff20, 0x02 },
    { 0xff01, 0x00 },  // choose data direction
    { 0xff03, 0x00 },  // choose data direction
    { 0xff00, 0x00 },  // inputs
    { 0xff02, 0xff },  // outputs
    { 0xff01, 0x34 },
    { 0xff03, 0x34 },
    { 0 }
};


// gime_reset_sequence table traced from coco3 startup.
struct gime_reset_sequence {
    gword addr;
    gbyte value;
} gime_reset_sequence[] gSETUP_DATA = {
// Generated by copico-bonobo/v2.4/firmware/c$ py gime_init_gen.py 
  { 0xff90, 0xcc },
  { 0xff91, 0x00 },
  { 0xff92, 0x00 },
  { 0xff93, 0x00 },
  { 0xff94, 0xff },
  { 0xff95, 0xff },
  { 0xff96, 0x00 },
  { 0xff97, 0x00 },
  { 0xff98, 0x00 },
  { 0xff99, 0x00 },
  { 0xff9a, 0x00 },
  { 0xff9b, 0x00 },
  { 0xff9c, 0x0f },
  { 0xff9d, 0xe0 },
  { 0xff9e, 0x00 },
  { 0xff9f, 0x00 },
  { 0xffa0, 0x38 },
  { 0xffa1, 0x39 },
  { 0xffa2, 0x3a },
  { 0xffa3, 0x3b },
  { 0xffa4, 0x3c },
  { 0xffa5, 0x3d },
  { 0xffa6, 0x3e },
  { 0xffa7, 0x3f },
  { 0xffa8, 0x38 },
  { 0xffa9, 0x30 },
  { 0xffaa, 0x31 },
  { 0xffab, 0x32 },
  { 0xffac, 0x33 },
  { 0xffad, 0x3d },
  { 0xffae, 0x35 },
  { 0xffaf, 0x3f },
  { 0xffb0, 0x12 },
  { 0xffb1, 0x24 },
  { 0xffb2, 0x0b },
  { 0xffb3, 0x07 },
  { 0xffb4, 0x3f },
  { 0xffb5, 0x1f },
  { 0xffb6, 0x09 },
  { 0xffb7, 0x26 },
  { 0xffb8, 0x00 },
  { 0xffb9, 0x12 },
  { 0xffba, 0x00 },
  { 0xffbb, 0x3f },
  { 0xffbc, 0x00 },
  { 0xffbd, 0x12 },
  { 0xffbe, 0x00 },
  { 0xffbf, 0x26 },
  { 0 }
};

void Delay(gword n) {
    for (gword i = 0; i < n; i++) {
        asm volatile(" mul \n mul \n mul \n mul \n mul" : : : "d");
    }
}

void RamRefresh() {
  // Before configuring SAM, give everything a refresh
  // by rereading all 16K RAM.
  for (gword p = 0; p < 0x4000; p+=2) {
    gPeek2(p);
  }
}

void SamInit() {
    // For p the even numbers in the magic SAM range:
    for (gword p = 0xFFC0; p < 0xFFE0; p+=2) {
        gPoke1(p, 0);
    }
    // But poke 0xFFDF for "TY=1" for "all ram, no rom".
    // This may matter on a coco3 for changing the irq vectors
    // in the $FExx page.
    gPoke1(0xFFDF, 0);

    // SAM has a setting for 4K, 16K, or 64K.
    // Probe for keys 0 (4K) and 1 (64K).  Default is 16K.
    gPoke1(0xFF02, ~1); // probe for '0'
    gbyte zero = ~(0x10 & gPeek1(0xFF00)); // sense for '0'
    gPoke1(0xFF02, ~2); // probe for '0'
    gbyte one = ~(0x10 & gPeek1(0xFF00)); // sense for '1'
    if (zero) {
        // No change.      // M=00 for 4K
    } else if (one) {
        gPoke1(0xffdd, 0);  // M=10 for 64K
    } else {
        gPoke1(0xffdb, 0);  // M=01 for 16K
    }
}

void memsetWords(gword p, gword value, gword num_bytes) {
    for (gword i = 0; i<num_bytes; i+=2) {
        gPoke2(p+i, value);
    }
}

void entry_wrapper() {
    asm volatile("\n"
        "  .globl entry \n"
        "entry:         \n"
        "  orcc #$50    \n"  // No IRQs, FIRQs, for now.
        "  lds #$01FE   \n"  // Reset the stack
        "  jmp _main    \n"
        );
}

extern void embark(void);

gword PinDownGlobalNames[] gSETUP_DATA = {
    // Taking the address of `embark` prevents it from being
    // inlined inside main.  Only things inlined inside main
    // are in the area called `.text.startup` which gets
    // recycled after setup, when we embark.
    (gword) embark,

    // Taking the address of other things in the kernel
    // prevents them from being optimized away.
    // Things that might be referenced by games
    // need to exist in the compiled kernel!
    (gword) Breakkey_Handler,
    (gword) Irq_Handler,
    (gword) Irq_Handler_entry,
    (gword) Irq_Handler_Wrapper,
    (gword) Network_Handler,
    (gword) gAlloc64,
    (gword) gFree64,
    (gword) Reset64,
    (gword) gSendCast,
    (gword) gReceiveCast64,

    (gword) gTextScreen,
    (gword) gPMode1Screen,
    (gword) gModeScreen,
    (gword) xAfterSetup,
    (gword) xSendControlPacket,
    (gword) gNetworkLog,
    (gword) gFatal,
    (gword) PutStr,
    (gword) PutChar,

    (gword) entry_wrapper,
    (gword) &_More0,
    (gword) &_More1,
    (gword) &_Final,
    (gword) &_Final_Startup,
    (gword) &gScore,
    (gword) &gReal,
    (gword) &gWall,
    (gword) &gConfig,
};

void PlaceOpcodeJMP(gword at, gfunc to) {
    gPoke1(at+0, OPCODE_JMP_Extended);
    gPoke2(at+1, to);
}

// Interrupt Relays
gword coco2_relays[] gSETUP_DATA = {
    0x0100,
    0x0103,
    0x010F,
    0x010C,
    0x0106,
    0x0109,
};
gword coco3_relays[] gSETUP_DATA = {
    0xFEEE,
    0xFEF1,
    0xFEF4,
    0xFEF7,
    0xFEFA,
    0xFEFD,
};
gfunc handlers[] gSETUP_DATA = {
    gFatalSWI3,
    gFatalSWI2,
    gFatalFIRQ,
    Irq_Handler_entry,
    gFatalSWI1,
    gFatalNMI,
};

char StrNekotMicrokernel[] gSETUP_DATA = "\nNEKOT MICROKERNEL... ";
char StrReady[] gSETUP_DATA = " READY\n";

void setup(void) {
    // Redirect the 6 Interrupt Relays to our handlers.
    for (gbyte i = 0; i < 6; i++) {
        PlaceOpcodeJMP(coco2_relays[i], handlers[i]);
        PlaceOpcodeJMP(coco3_relays[i], handlers[i]);
    }

    RamRefresh();
    SamInit();
    for (struct gime_reset_sequence *p = gime_reset_sequence; p->addr; p++) {
        gPoke1(p->addr, p->value);
    }
    for (struct pia_reset_sequence *p = pia_reset_sequence; p->addr; p++) {
        gPoke1(p->addr, p->value);
    }
    // Coco3 in Compatibility Mode.
    gPoke1(0xFF90, 0x88);
    gPoke1(0xFF91, 0x00);

    // Value is a word, but count is in bytes:
    memsetWords(0x0000, 0, 0x80); // .bss
    memsetWords(0x0080, 0x1B1D, 0x80); // Poke "[]" patterns.
    memsetWords(0x0200, 0, 0x100); // vdg console p1
    memsetWords(0x0300, 0, 0x100); // vdg console p2
    memsetWords(0x0400, 0, 0x100); // chunks of 64-gbyte
    Delay(10000);

    // The post-linker puts Version Hash at $0118.
    // Copy Version Hash down to page 0, at $0018.
    memcpy(0x0018, 0x0118, 8);

    Alloc64_Init();  // first 4 chunks in 0x04XX.
    Kern_Init();

    Console_Init();
    Vdg_Init();

    PutStr(StrNekotMicrokernel);
    Delay(10000);

    Spin_Init();
    Network_Init();
    HelloMCP();

    gPeek1(0xFF02);        // Clear VSYNC IRQ // TODO
    gPoke1(0xFF03, 0x35);  // +1: Enable VSYNC (FS) IRQ

    PutStr(StrReady);
    Delay(10000);
}

void embark(void) {
    // Wipe out the setup/startup code, to prove it is never needed again.
#if 1
    for (gword p = 2 + (gword)&_Final;
         p < (gword)_Final_Startup;
         p+=2) {
        gPoke2(p, 0x3F3F);
    }
#endif

    StartTask((gword)ChatTask); // Start the no-game task.
}

int main() {
    setup();
    embark();

    // NOT REACHED

    gPin(PinDownGlobalNames);
    gFatal("MAIN", 0);
}
